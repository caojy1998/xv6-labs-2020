xv6 is a re-implementation of Dennis Ritchie's and Ken Thompson's Unix
Version 6 (v6).  xv6 loosely follows the structure and style of v6,
but is implemented for a modern RISC-V multiprocessor using ANSI C.

ACKNOWLEDGMENTS

xv6 is inspired by John Lions's Commentary on UNIX 6th Edition (Peer
to Peer Communications; ISBN: 1-57398-013-7; 1st edition (June 14,
2000)). See also https://pdos.csail.mit.edu/6.828/, which
provides pointers to on-line resources for v6.

The following people have made contributions: Russ Cox (context switching,
locking), Cliff Frey (MP), Xiao Yu (MP), Nickolai Zeldovich, and Austin
Clements.

We are also grateful for the bug reports and patches contributed by
Silas Boyd-Wickizer, Anton Burtsev, Dan Cross, Cody Cutler, Mike CAT,
Tej Chajed, Asami Doi, eyalz800, , Nelson Elhage, Saar Ettinger, Alice
Ferrazzi, Nathaniel Filardo, Peter Froehlich, Yakir Goaron,Shivam
Handa, Bryan Henry, jaichenhengjie, Jim Huang, Alexander Kapshuk,
Anders Kaseorg, kehao95, Wolfgang Keller, Jonathan Kimmitt, Eddie
Kohler, Austin Liew, Imbar Marinescu, Yandong Mao, Matan Shabtay,
Hitoshi Mitake, Carmi Merimovich, Mark Morrissey, mtasm, Joel Nider,
Greg Price, Ayan Shafqat, Eldar Sehayek, Yongming Shen, Fumiya
Shigemitsu, Takahiro, Cam Tenny, tyfkda, Rafael Ubal, Warren Toomey,
Stephen Tu, Pablo Ventura, Xi Wang, Keiichi Watanabe, Nicolas
Wolovick, wxdao, Grant Wu, Jindong Zhang, Icenowy Zheng, and Zou Chang
Wei.

The code in the files that constitute xv6 is
Copyright 2006-2020 Frans Kaashoek, Robert Morris, and Russ Cox.

ERROR REPORTS

Please send errors and suggestions to Frans Kaashoek and Robert Morris
(kaashoek,rtm@mit.edu). The main purpose of xv6 is as a teaching
operating system for MIT's 6.S081, so we are more interested in
simplifications and clarifications than new features.

BUILDING AND RUNNING XV6

You will need a RISC-V "newlib" tool chain from
https://github.com/riscv/riscv-gnu-toolchain, and qemu compiled for
riscv64-softmmu. Once they are installed, and in your shell
search path, you can run "make qemu".

以下是关于作业的一些remark：
首先pagetable在实现的时候是一个指针pagetable_t，但并没有直接的说存储3级页表。因为这边都是指针映射，所以也解释了为什么不能free leaf page
satp是和root pagetable联系在一起的。

结合实验分析课的一些remark：
stack以下的部分占3个pagetable的大小。data和text是在一个page里的，这边只是为了方便，但是实际操作系统中不会这样设计。guardpage的最后是0f，其余的都是1f。这些都是flags。
最高位的地址是trampoline之类的东西。但是为什么这个最高位的虚拟地址是255不是511？因为riscv只用了39个bit中的38个。

这边需要澄清的一点是，复制的方法也是可以使用的。同时由于大部分复制的东西是可以使用的，所以只要补上没有使用的那一部分就可以了，遍历循环的时候是1到512，0所占据的1GB的内容是没有被复制的，
所以就解释了为什么只有4条初始化被延续下来，貌似这4条涉及的是user的部分，没法直接复制。补充：KERNBASE对应的最高级entry是2.
但同时CLINT这个量在这边也被写到kernel_pagetable当中去了，所以是否有必要去掉这个，原因？

关于第3部分：
这边还是强调不需要按页复制，因为所有的地址都已经map到kernel里了（可能是identical map）。write这个系统调用就要求从user space写大量信息到kernel。
问题：这边一做map的话，会把kernel的isolation给break掉吗？
PTE_U可能有点保证isolation的功能。总体而言，后面三个bit U W X的控制是为了debugging reason，确保kernel在这边只有读取user space信息的权限
高级思考题：为什么在fork中是把新的pagetable复制给新的kernel_pagetable。是因为如果在复制之前parent process exit了，就复制不了了。这边并没有加一个lock。

